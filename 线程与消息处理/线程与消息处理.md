# 安卓线程与消息处理

## 一、线程启动的几种方式

### 1.启动线程的第一种方法：继承Thread类

```java
public class Thread01  {
    public static void main(String[] args) {
        //创建线程对象
        MyThread myThread = new MyThread();
        //启动线程
        myThread.start();

        //主线程
        for (int i = 0; i <100 ; i++) {
            System.out.println("main主线程--->" + i);
        }

    }
}
class MyThread extends Thread{
    @Override
    public void run() {
        for (int i = 0; i <100 ; i++) {
            System.out.println("分支线程---->"+ i);
        }
    }
}

```

### 2.启动线程的第二种方式：实现Runnable接口

```java
public class Thread02 {
    public static void main(String[] args) {
        //创建线程对象
        Thread thread = new Thread(new MyRunnable());
        //启动线程
        thread.start();

        //主线程
        for (int i = 0; i <100 ; i++) {
            System.out.println("main主线程--->" + i);
        }
    }
}
class MyRunnable implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i <100 ; i++) {
            System.out.println("分支线程---->"+ i);
        }
    }
}

```

### 3.匿名内部类

```java
public class Thread03 {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <1000 ; i++) {
                    System.out.println("分支线程-->" + i);
                }
            }
        });

        //启动线程
        thread.start();

        //主线程
        for (int i = 0; i <1000 ; i++) {
            System.out.println("main主线程--->"+ i);
        }
    }
}

```

### 4.实现Callable接口

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/***
 * 启动线程的第三种方法：实现Callable接口,重写call()方法
 */
public class ThreadTest04 {
    public static void main(String[] args) {
        //创建一个“未来任务类”对象
        FutureTask futureTask = new FutureTask(new Callable() {
            @Override
            public Object call() throws Exception { //call()方法相当与run()方法，比run方法好，有返回值
                System.out.println("call mothed begin!");
                Thread.sleep(1000 * 10);
                System.out.println("call mothed over!");

                int x = 100;
                int y = 200;

                return x + y;//自动装箱
            }
        });

        //创建线程对象
        Thread t = new Thread(futureTask);

        //启动线程
        t.start();

        Object obj = null;
        //获得分支线程返回值
        try {
            //get()方法的执行会导致主线程的阻塞
            obj = futureTask.get();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println("获得分支线程的返回值：" + obj );

        //如下的代码会等到分支线程执行结束后，才回到主线程中继续执行
        System.out.println("Hello CSDN");
    }
}


```

## 安卓能否在主线程实现耗时操作？

![image-20220905160310805](D:\安卓开发笔记\线程与消息处理\线程与消息处理.assets\image-20220905160310805.png)

超过5秒系统无响应

## 安卓子线程能否更新UI？

不能更新UI调用

```java
runOnUiThread(new Runnable() {
                    @Override
                    public void run() {

                    }
                });
```

## 二、线程通信Handler机制

首先在主线程中创建Handler对象

同事重写handlerMassage方法在其判断接收子线程传过来的信息

在子线程中创建Message对象传入数据

调用handler.sendMessage方法传入Message对象

![image-20220905211013747](线程与消息处理.assets/image-20220905211013747.png)

```java
Handler mhandler = new Handler(Looper.myLooper()){

    @Override
    public void handleMessage(Message msg) {

        super.handleMessage(msg);
        if(msg.what == 0){
            String s = (String) msg.obj;
            tv_textView.setText("结果为"+s);
        }
    }
};
```

```java
@Override
public void onClick(View view) {

    Toast.makeText(this,"计算完成",Toast.LENGTH_SHORT).show();

    new Thread(new Runnable() {
        @Override
        public void run() {
            Message message = new Message();
            String s = waitFor();
            message.what = 0;
            message.obj = s;
            mhandler.sendMessage(message);


        }
    }).start();
}
```

![image-20220906145748666](线程与消息处理.assets/image-20220906145748666.png)



![image-20220906145728473](线程与消息处理.assets/image-20220906145728473.png)

完整代码

```java
package com.example.newland.thread;

import android.content.Context;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.health.TimerStat;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Timer;
import java.util.TimerTask;

public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private TextView tv_textView;

    Handler mhandler = new Handler(Looper.myLooper()){

        @Override
        public void handleMessage(Message msg) {

            super.handleMessage(msg);
            if(msg.what == 0){
                String s = (String) msg.obj;
                tv_textView.setText("结果为"+s);
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        findViewById(R.id.btn_time).setOnClickListener(this);
        tv_textView = findViewById(R.id.tv_textView);
    }

    private String waitFor(){

        String s = "1";
        for (int i = 0; i <6 ; i++) {

            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            s=s+"0";
        }
        return s;
    }

    @Override
    public void onClick(View view) {

        Toast.makeText(this,"计算完成",Toast.LENGTH_SHORT).show();

        new Thread(new Runnable() {
            @Override
            public void run() {
                Message message = new Message();
                String s = waitFor();
                message.what = 0;
                message.obj = s;
                mhandler.sendMessage(message);


            }
        }).start();
    }
}
```

## 三、Timer和TimerTask

这两个类是配对使用的Timer类用于定时TimerTask类用于受Timer类的约束来执行操作的线程

创建TimerTask类的对象传入实现Runnable接口的类重写Run方法里面是重复执行的任务

创建Timer对象

调用schedule()方法传入参数TimerTask对象，延时时间执行的一次，每次执行间隔时间、

类似于单片机定时器

```java
package com.example.newland.thread;

import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;

import java.util.Timer;
import java.util.TimerTask;

public class Main2Activity extends AppCompatActivity implements View.OnClickListener {

    private int time = 10;
    private TextView tv_time;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main2);

        findViewById(R.id.btn_start).setOnClickListener(this);
        tv_time = findViewById(R.id.tv_time);
    }

    @Override
    public void onClick(View view) {



        timer.schedule(timerTask,0,1000);
    }

    Timer timer = new Timer();
    TimerTask timerTask = new TimerTask() {
        @Override
        public void run() {

                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {

                        tv_time.setText(String.valueOf(time));
                        time--;
                        if(time<0){
                        timer.cancel();
                    }
                }
                });
            }
    };
}
```

```html
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <Button
        android:id="@+id/btn_start"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="开始倒计时"/>

    <TextView
        android:id="@+id/tv_time"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="22sp"/>
</LinearLayout>
```

![image-20220906152958445](线程与消息处理.assets/image-20220906152958445.png)